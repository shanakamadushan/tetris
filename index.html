<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tetris – Mobile-Optimized JS</title>
  <style>
    :root {
      --bg: #0f1220;
      --panel: #151a2d;
      --accent: #7c9cff;
      --text: #e7ebff;
      --muted: #a3acc3;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
      background: radial-gradient(1200px 800px at 70% -10%, #1a2040, var(--bg));
      color:var(--text); display:flex; justify-content:center; align-items:center; padding:10px;
    }
    .wrap{
      display:grid; grid-template-columns: 1fr 220px; gap:16px; align-items:start;
      width:min(920px,96vw); background: linear-gradient(180deg, #12162a, #0f1220);
      border:1px solid #1f2848; border-radius:18px; padding:14px; box-shadow:var(--shadow);
    }
    .playarea{display:flex; flex-direction:column; align-items:center; gap:12px;}
    canvas{display:block; background:#0a0d1a; border-radius:12px; box-shadow: inset 0 0 0 1px #1e2442; touch-action:none}
    .side{display:grid; gap:12px}
    .card{background:var(--panel); border:1px solid #1f2848; border-radius:14px; padding:12px; box-shadow:var(--shadow)}
    .title{font-weight:700; letter-spacing:.2px; font-size:14px; color:var(--muted); margin-bottom:8px; text-transform:uppercase}
    .stats{display:grid; grid-template-columns: 1fr 1fr; gap:6px}
    .stats .item{background:#12172a; border:1px solid #1f2848; border-radius:10px; padding:10px; text-align:center}
    .stats .k{display:block; font-size:11px; color:var(--muted); text-transform:uppercase; letter-spacing:.3px}
    .stats .v{font-size:18px; font-weight:800}
    .grid-preview{display:grid; grid-template-columns: repeat(4, 20px); grid-auto-rows:20px; gap:2px}
    .cell{width:20px; height:20px; background:#161c34; border-radius:4px}
    .cell.f{box-shadow: inset 0 0 0 1px rgba(255,255,255,.08)}

    /* Mobile control pad */
    .controls{display:grid; grid-template-columns: repeat(4,1fr); gap:10px; width:100%;}
    .controls button{padding:14px 10px; font-size:18px; font-weight:800; border-radius:14px; border:1px solid #26305a; color:var(--text); background:linear-gradient(180deg,#1b2344,#151a32); box-shadow:var(--shadow)}
    .controls .wide{grid-column: span 2}

    .top-actions{display:flex; gap:8px; width:100%;}
    .top-actions button{flex:1; padding:10px; font-weight:700; border-radius:12px; border:1px solid #26305a; color:var(--text); background:#192146}

    @media (max-width: 780px){
      .wrap{grid-template-columns: 1fr;}
      .side{order:2}
      .playarea{order:1}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="playarea">
      <div class="top-actions">
        <button id="startBtn" class="primary">Start</button>
        <button id="pauseBtn">Pause</button>
        <button id="resetBtn">Reset</button>
      </div>
      <canvas id="board" width="320" height="640" aria-label="Tetris playfield" role="img"></canvas>
      <!-- On-screen mobile controls -->
      <div class="controls" aria-label="Mobile controls">
        <button id="btnLeft" aria-label="Move Left">◀</button>
        <button id="btnRotateL" aria-label="Rotate Left">⟲</button>
        <button id="btnRotateR" aria-label="Rotate Right">⟳</button>
        <button id="btnRight" aria-label="Move Right">▶</button>
        <button id="btnSoft" class="wide" aria-label="Soft Drop">⏬ Soft</button>
        <button id="btnHard" class="wide" aria-label="Hard Drop">⤓ Hard</button>
      </div>
    </div>

    <aside class="side">
      <div class="card">
        <div class="title">Stats</div>
        <div class="stats">
          <div class="item"><span class="k">Score</span><span id="score" class="v">0</span></div>
          <div class="item"><span class="k">Lines</span><span id="lines" class="v">0</span></div>
          <div class="item"><span class="k">Level</span><span id="level" class="v">0</span></div>
          <div class="item"><span class="k">Speed</span><span id="speed" class="v">1.00x</span></div>
        </div>
      </div>
      <div class="card">
        <div class="title">Next</div>
        <div id="next" class="grid-preview" aria-live="polite"></div>
      </div>
      <div class="card">
        <div class="title">Hold</div>
        <div id="hold" class="grid-preview"></div>
      </div>
      <div class="card">
        <div class="title">Keyboard</div>
        <div class="stats" style="grid-template-columns:1fr 1fr">
          <div class="item"><span class="k">Move</span><span class="v">← →</span></div>
          <div class="item"><span class="k">Rotate</span><span class="v">↑ Z X</span></div>
          <div class="item"><span class="k">Drop</span><span class="v">↓ / Space</span></div>
          <div class="item"><span class="k">Hold</span><span class="v">C</span></div>
        </div>
      </div>
    </aside>
  </div>

  <script>
    // --- Configuration (responsive) ---
    const COLS = 10, ROWS = 20;
    let CELL = 32; // dynamically sized
    let BOARD_W = COLS * CELL, BOARD_H = ROWS * CELL;

    const COLORS = { I: "#5ee7ff", J: "#6388ff", L: "#ff9f43", O: "#ffd43b", S: "#51cf66", T: "#c77dff", Z: "#ff6b6b", ghost: "#2b335c" };

    const SHAPES = {
      I: [
        [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
        [[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0]],
        [[0,0,0,0],[0,0,0,0],[1,1,1,1],[0,0,0,0]],
        [[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]],
      ],
      O: [
        [[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
        [[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
        [[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
        [[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
      ],
      T: [
        [[0,1,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
        [[0,1,0,0],[0,1,1,0],[0,1,0,0],[0,0,0,0]],
        [[0,0,0,0],[1,1,1,0],[0,1,0,0],[0,0,0,0]],
        [[0,1,0,0],[1,1,0,0],[0,1,0,0],[0,0,0,0]],
      ],
      S: [
        [[0,1,1,0],[1,1,0,0],[0,0,0,0],[0,0,0,0]],
        [[0,1,0,0],[0,1,1,0],[0,0,1,0],[0,0,0,0]],
        [[0,0,0,0],[0,1,1,0],[1,1,0,0],[0,0,0,0]],
        [[1,0,0,0],[1,1,0,0],[0,1,0,0],[0,0,0,0]],
      ],
      Z: [
        [[1,1,0,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
        [[0,0,1,0],[0,1,1,0],[0,1,0,0],[0,0,0,0]],
        [[0,0,0,0],[1,1,0,0],[0,1,1,0],[0,0,0,0]],
        [[0,1,0,0],[1,1,0,0],[1,0,0,0],[0,0,0,0]],
      ],
      J: [
        [[1,0,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
        [[0,1,1,0],[0,1,0,0],[0,1,0,0],[0,0,0,0]],
        [[0,0,0,0],[1,1,1,0],[0,0,1,0],[0,0,0,0]],
        [[0,1,0,0],[0,1,0,0],[1,1,0,0],[0,0,0,0]],
      ],
      L: [
        [[0,0,1,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
        [[0,1,0,0],[0,1,0,0],[0,1,1,0],[0,0,0,0]],
        [[0,0,0,0],[1,1,1,0],[1,0,0,0],[0,0,0,0]],
        [[1,1,0,0],[0,1,0,0],[0,1,0,0],[0,0,0,0]],
      ],
    };

    const KICKS = [ {x:0,y:0}, {x:1,y:0}, {x:-1,y:0}, {x:0,y:-1}, {x:2,y:0}, {x:-2,y:0} ];
    const LEVEL_SPEEDS = [0.8,0.72,0.63,0.55,0.47,0.4,0.32,0.26,0.2,0.16,0.13,0.1,0.08,0.07,0.05];

    // DOM
    const $ = s=>document.querySelector(s);
    const board=$('#board');
    const ctx=board.getContext('2d');
    const ui={score:$('#score'),lines:$('#lines'),level:$('#level'),speed:$('#speed'),next:$('#next'),hold:$('#hold')};

    function initPreview(el){ el.innerHTML=''; for(let i=0;i<4*5;i++){ const d=document.createElement('div'); d.className='cell'; el.appendChild(d);} }
    initPreview(ui.next); initPreview(ui.hold);

    // Game state
    let grid, active, queue, hold, canHold, score, lines, level, over, paused;
    let fallTimer=0, fallInterval=LEVEL_SPEEDS[0];

    const emptyRow=()=>Array(COLS).fill(null);
    const makeGrid=()=>Array(ROWS).fill(0).map(emptyRow);

    function initIdle(){
      grid = makeGrid(); active=null; queue=[]; hold=null; canHold=true;
      score=0; lines=0; level=0; over=false; paused=true; fallTimer=0; fallInterval=LEVEL_SPEEDS[0];
      updateSidebar(); drawBoard();
    }

    function newGame(){
      grid = makeGrid(); queue=makeBag(); hold=null; canHold=true;
      active=spawn(); score=0; lines=0; level=0; over=false; paused=false;
      fallTimer=0; fallInterval=LEVEL_SPEEDS[level]; updateSidebar(); draw();
    }

    function makeBag(){ const pieces=['I','J','L','O','S','T','Z']; for(let i=pieces.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [pieces[i],pieces[j]]=[pieces[j],pieces[i]];} return pieces; }
    function takeNext(){ if(queue.length===0) queue=makeBag(); return queue.shift(); }

    function spawn(){ const t=takeNext(); const piece={type:t, r:0, x:3, y:0}; if(collides(piece, grid)){ over=true; paused=true; } return piece; }

    function rotate(dir){ if(over||paused||!active) return; const p={...active, r:(active.r + (dir>0?1:3))%4}; for(const k of KICKS){ const test={...p, x:p.x+k.x, y:p.y+k.y}; if(!collides(test, grid)){ active=test; draw(); return; } } }
    function move(dx){ if(over||paused||!active) return; const p={...active, x:active.x+dx}; if(!collides(p,grid)){ active=p; draw(); } }
    function softDrop(){ if(over||paused||!active) return; const p={...active, y:active.y+1}; if(!collides(p,grid)){ active=p; score+=1; draw(); } else lockPiece(); }
    function hardDrop(){ if(over||paused||!active) return; let dist=0; let p={...active}; while(true){ const n={...p,y:p.y+1}; if(collides(n,grid)) break; p=n; dist++; } active=p; score+=2*dist; lockPiece(); }
    function holdSwap(){ if(over||paused||!active||!canHold) return; const t=active.type; if(hold){ active={type:hold,r:0,x:3,y:0}; hold=t; } else { hold=t; active=spawn(); } canHold=false; updateSidebar(); draw(); }

    function collides(p,g){ const shape=SHAPES[p.type][p.r]; for(let r=0;r<4;r++){ for(let c=0;c<4;c++){ if(!shape[r][c]) continue; const x=p.x+c, y=p.y+r; if(x<0||x>=COLS||y>=ROWS) return true; if(y>=0 && g[y][x]) return true; } } return false; }
    function mergePiece(){ const shape=SHAPES[active.type][active.r]; for(let r=0;r<4;r++) for(let c=0;c<4;c++) if(shape[r][c]){ const x=active.x+c, y=active.y+r; if(y>=0) grid[y][x]=active.type; } }
    function clearLines(){ let cleared=0; for(let r=ROWS-1;r>=0;r--){ if(grid[r].every(v=>v)){ grid.splice(r,1); grid.unshift(emptyRow()); cleared++; r++; } } if(cleared){ const points=[0,100,300,500,800][cleared]*(level+1); score+=points; lines+=cleared; level=Math.min(14, Math.floor(lines/10)); fallInterval=LEVEL_SPEEDS[level]; } }
    function lockPiece(){ mergePiece(); clearLines(); active=spawn(); canHold=true; updateSidebar(); draw(); }

    // Rendering
    function drawCell(x,y,color,ghost=false){ const px=x*CELL, py=y*CELL; ctx.fillStyle=ghost?COLORS.ghost:color; ctx.fillRect(px+1,py+1,CELL-2,CELL-2); if(!ghost){ const g=ctx.createLinearGradient(px,py,px,py+CELL); g.addColorStop(0,'rgba(255,255,255,.12)'); g.addColorStop(0.5,'rgba(255,255,255,.04)'); g.addColorStop(1,'rgba(0,0,0,.18)'); ctx.fillStyle=g; ctx.fillRect(px+1,py+1,CELL-2,CELL-2);} }
    function drawBoard(){ ctx.clearRect(0,0,BOARD_W,BOARD_H); ctx.globalAlpha=0.35; ctx.strokeStyle='#1a2142'; for(let x=1;x<COLS;x++){ ctx.beginPath(); ctx.moveTo(x*CELL,0); ctx.lineTo(x*CELL,BOARD_H); ctx.stroke(); } for(let y=1;y<ROWS;y++){ ctx.beginPath(); ctx.moveTo(0,y*CELL); ctx.lineTo(BOARD_W,y*CELL); ctx.stroke(); } ctx.globalAlpha=1; for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){ const t=grid[r][c]; if(t) drawCell(c,r,COLORS[t]); } }
    function ghostOf(p){ let g={...p}; while(!collides({...g,y:g.y+1},grid)) g.y++; return g; }
    function drawActive(){ if(!active) return; const shape=SHAPES[active.type][active.r]; const gh=ghostOf(active); for(let r=0;r<4;r++) for(let c=0;c<4;c++) if(shape[r][c]) drawCell(gh.x+c, gh.y+r, COLORS.ghost, true); for(let r=0;r<4;r++) for(let c=0;c<4;c++) if(shape[r][c]) drawCell(active.x+c, active.y+r, COLORS[active.type]); }
    function draw(){ drawBoard(); drawActive(); if(over){ ctx.fillStyle='rgba(0,0,0,.55)'; ctx.fillRect(0,0,BOARD_W,BOARD_H); ctx.fillStyle='#fff'; ctx.font='bold 28px ui-sans-serif, system-ui'; ctx.textAlign='center'; ctx.fillText('Game Over', BOARD_W/2, BOARD_H/2-10); ctx.font='14px ui-sans-serif, system-ui'; ctx.fillText('Press Reset to play again', BOARD_W/2, BOARD_H/2+18); } }

    function updateSidebar(){ ui.score.textContent=score; ui.lines.textContent=lines; ui.level.textContent=level; const sp=(LEVEL_SPEEDS[0]/LEVEL_SPEEDS[level]).toFixed(2)+'x'; ui.speed.textContent=sp; const list=(queue&&queue.length?queue:[]).slice(0,5); renderMini(ui.next, list); renderMini(ui.hold, hold?[hold]:[]); }
    function renderMini(container, list){ const cells=Array.from(container.children); cells.forEach(c=>{c.className='cell'; c.style.background='';}); let rowOffset=0; list.forEach(t=>{ const shape=SHAPES[t][0]; let minR=4,maxR=0,minC=4,maxC=0; for(let r=0;r<4;r++) for(let c=0;c<4;c++) if(shape[r][c]){ minR=Math.min(minR,r); maxR=Math.max(maxR,r); minC=Math.min(minC,c); maxC=Math.max(maxC,c);} const w=(maxC-minC+1); const startCol=Math.floor((4-w)/2); for(let r=minR;r<=maxR;r++) for(let c=minC;c<=maxC;c++) if(shape[r][c]){ const rr=rowOffset + r-minR; const cc=startCol + c-minC; const idx=rr*4 + cc; if(cells[idx]){ cells[idx].classList.add('f'); cells[idx].style.background=COLORS[t]; } } rowOffset+=4; }); }

    // Game loop
    let last=0; function tick(ts){ if(!last) last=ts; const dt=(ts-last)/1000; last=ts; if(!paused && !over && active){ fallTimer+=dt; if(fallTimer>=fallInterval){ fallTimer=0; const p={...active,y:active.y+1}; if(!collides(p,grid)){ active=p; } else { lockPiece(); } draw(); } } requestAnimationFrame(tick); }

    // Resize & responsive scaling
    function resizeCanvas(){
      // On narrow screens, fill width. Keep 10:20 ratio
      const container = document.querySelector('.playarea');
      const maxW = container.clientWidth; // available width
      const maxH = Math.max(360, window.innerHeight*0.6);
      // pick the largest CELL that fits
      const cellW = Math.floor(maxW / COLS);
      const cellH = Math.floor(maxH / ROWS);
      CELL = Math.max(14, Math.min(cellW, cellH)); // min size 14px for tapability
      BOARD_W = COLS*CELL; BOARD_H = ROWS*CELL;
      board.width = BOARD_W; board.height = BOARD_H;
      draw();
    }
    window.addEventListener('resize', resizeCanvas);

    // Buttons & pointers (with press-and-hold repeat)
    function bindHold(btn, fn, repeatMs=110){
      let t; const start=()=>{ fn(); t=setInterval(fn, repeatMs); }; const end=()=>{ clearInterval(t); };
      btn.addEventListener('pointerdown', e=>{ e.preventDefault(); btn.setPointerCapture(e.pointerId); start(); });
      ['pointerup','pointercancel','pointerleave'].forEach(ev=>btn.addEventListener(ev, end));
      btn.addEventListener('click', e=>{ e.preventDefault(); }); // prevent double-fire on mobile
    }
    bindHold($('#btnLeft'), ()=>move(-1));
    bindHold($('#btnRight'), ()=>move(1));
    $('#btnRotateL').addEventListener('click', ()=>rotate(-1));
    $('#btnRotateR').addEventListener('click', ()=>rotate(1));
    bindHold($('#btnSoft'), ()=>softDrop(), 70);
    $('#btnHard').addEventListener('click', ()=>hardDrop());

    // Keyboard
    document.addEventListener('keydown', e=>{
      switch(e.code){
        case 'ArrowLeft': move(-1); break;
        case 'ArrowRight': move(1); break;
        case 'ArrowDown': softDrop(); break;
        case 'ArrowUp': rotate(1); break;
        case 'KeyZ': rotate(-1); break;
        case 'KeyX': rotate(1); break;
        case 'Space': e.preventDefault(); hardDrop(); break;
        case 'KeyC': holdSwap(); break;
        case 'KeyP': togglePause(); break;
      }
    });

    // Swipe gestures on canvas
    let touchStart=null; board.addEventListener('touchstart', e=>{ if(e.touches.length>0) touchStart={x:e.touches[0].clientX, y:e.touches[0].clientY}; }, {passive:true});
    board.addEventListener('touchend', e=>{
      if(!touchStart) return; const t=e.changedTouches[0]; const dx=t.clientX - touchStart.x; const dy=t.clientY - touchStart.y; const ax=Math.abs(dx), ay=Math.abs(dy); const TH=24;
      if(ax<TH && ay<TH){ // tap: rotate
        rotate(1);
      } else if(ax>ay){ if(dx>0) move(1); else move(-1); }
      else { if(dy>0) softDrop(); else rotate(1); }
      touchStart=null;
    }, {passive:true});

    function togglePause(){ if(over) return; paused=!paused; $('#pauseBtn').textContent = paused? 'Resume':'Pause'; }
    $('#startBtn').addEventListener('click', ()=>newGame());
    $('#resetBtn').addEventListener('click', ()=>newGame());
    $('#pauseBtn').addEventListener('click', ()=>togglePause());

    // Self-tests (console)
    function deepCloneGrid(g){ return g.map(r=>r.slice()); }
    function expect(name, cond){ console.log((cond? '✅':'❌')+" "+name); return !!cond; }
    function runSelfTests(){
      const save={ grid:deepCloneGrid(grid), active, queue:queue?queue.slice():[], hold, canHold, score, lines, level, over, paused, fallTimer, fallInterval };
      try{
        const bag=makeBag(); expect('bag has 7', bag.length===7); expect('bag unique set', new Set(bag).size===7);
        const g0=makeGrid(); expect('collides left wall', collides({type:'I',r:0,x:-1,y:0}, g0));
        const ap={type:'O',r:0,x:3,y:0}; const gh=ghostOf(ap); expect('ghost bottom row', gh.y>=ROWS-2 && gh.y<ROWS);
        const g1=makeGrid(); g1[ROWS-1]=Array(COLS).fill('I'); grid=g1; level=0; lines=0; score=0; clearLines(); expect('bottom cleared', grid[ROWS-1].every(v=>v===null)); expect('lines incremented', lines===1);
      } finally {
        grid=save.grid; active=save.active; queue=save.queue; hold=save.hold; canHold=save.canHold; score=save.score; lines=save.lines; level=save.level; over=save.over; paused=save.paused; fallTimer=save.fallTimer; fallInterval=save.fallInterval; drawBoard();
      }
    }

    // Kick off
    initIdle();
    resizeCanvas();
    requestAnimationFrame(tick);
    runSelfTests();
  </script>
</body>
</html>
